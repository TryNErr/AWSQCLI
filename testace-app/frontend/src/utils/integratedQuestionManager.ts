import { Question, DifficultyLevel, QuestionType } from '../types';
import { comprehensiveReadingDatabase, ComprehensiveReadingDatabase } from './comprehensiveReadingDatabase';
import { generateRobustThinkingSkillsQuestions } from './robustThinkingSkillsGenerator';
import { generateEnhancedMathematicalReasoningQuestions } from './enhancedMathematicalReasoningGenerator';
import { generateEnhancedQuestion } from './enhancedQuestionSystem';
import { getAnsweredQuestionIds, addAnsweredQuestionId } from '../services/userProgressService';
import { getGeneratedQuestions, saveGeneratedQuestions } from '../services/generatedQuestionsService';
import { questionData } from '../pages/Practice/questionData';

/**
 * Integrated Question Management System
 * 
 * This system ensures:
 * 1. âœ… Questions are shared between users (global pool)
 * 2. âœ… Individual users don't see questions they've already answered correctly
 * 3. âœ… Auto-generation when minimum questions don't exist
 * 4. âœ… Seamless integration of all question sources
 */

interface QuestionRequest {
  grade: string;
  subject: string;
  difficulty: DifficultyLevel;
  count: number;
  userId?: string; // Optional for user-specific filtering
}

interface QuestionResponse {
  questions: Question[];
  source: 'database' | 'reading_passages' | 'generated' | 'mixed';
  totalAvailable: number;
  userFiltered: number;
  autoGenerated: number;
}

export class IntegratedQuestionManager {
  
  /**
   * Main method to get questions for any subject/grade/difficulty
   * Handles all the logic for user filtering and auto-generation
   */
  static async getQuestions(request: QuestionRequest): Promise<QuestionResponse> {
    const { grade, subject, difficulty, count, userId } = request;
    
    console.log(`ðŸŽ¯ Getting ${count} questions for Grade ${grade}, ${subject}, ${difficulty}`);
    
    // Get user's answered questions (only affects this user)
    const answeredQuestionIds = userId ? getAnsweredQuestionIds() : [];
    
    // Step 1: Get all available questions from all sources
    const allAvailableQuestions = await this.getAllAvailableQuestions(grade, subject, difficulty);
    
    console.log(`ðŸ“š Found ${allAvailableQuestions.length} total questions in global pool`);
    
    // Step 2: Filter out questions this user has already answered correctly
    const availableForUser = allAvailableQuestions.filter(q => 
      !answeredQuestionIds.includes(q._id)
    );
    
    console.log(`ðŸ‘¤ ${availableForUser.length} questions available for this user (filtered out ${allAvailableQuestions.length - availableForUser.length} already answered)`);
    
    // Step 3: Check if we have enough questions
    if (availableForUser.length >= count) {
      // We have enough questions - randomly select and return
      const selectedQuestions = this.shuffleArray(availableForUser).slice(0, count);
      
      return {
        questions: selectedQuestions,
        source: this.determineSource(selectedQuestions),
        totalAvailable: allAvailableQuestions.length,
        userFiltered: allAvailableQuestions.length - availableForUser.length,
        autoGenerated: 0
      };
    }
    
    // Step 4: We need more questions - auto-generate them
    const shortfall = count - availableForUser.length;
    console.log(`âš¡ Need to auto-generate ${shortfall} additional questions`);
    
    const generatedQuestions = await this.autoGenerateQuestions(grade, subject, difficulty, shortfall);
    
    // Step 5: Combine available + generated questions
    const allQuestions = [...availableForUser, ...generatedQuestions];
    const finalQuestions = this.shuffleArray(allQuestions).slice(0, count);
    
    // Step 6: Save generated questions to global pool for other users
    if (generatedQuestions.length > 0) {
      await this.saveGeneratedQuestionsToGlobalPool(generatedQuestions);
    }
    
    return {
      questions: finalQuestions,
      source: 'mixed',
      totalAvailable: allAvailableQuestions.length,
      userFiltered: allAvailableQuestions.length - availableForUser.length,
      autoGenerated: generatedQuestions.length
    };
  }
  
  /**
   * Get all available questions from all sources (global pool)
   */
  private static async getAllAvailableQuestions(
    grade: string, 
    subject: string, 
    difficulty: DifficultyLevel
  ): Promise<Question[]> {
    const allQuestions: Question[] = [];
    
    // Source 1: Original question database
    const originalQuestions = questionData.filter(q => 
      q.grade === grade && 
      q.subject === subject && 
      q.difficulty === difficulty
    );
    allQuestions.push(...originalQuestions);
    
    // Source 2: Reading comprehension database (for reading subjects)
    if (this.isReadingSubject(subject)) {
      const readingQuestions = ComprehensiveReadingDatabase.getQuestionsByGradeAndDifficulty(grade, difficulty);
      allQuestions.push(...readingQuestions);
    }
    
    // Source 3: Previously generated questions (shared between all users)
    const generatedQuestions = getGeneratedQuestions().filter(q =>
      q.grade === grade && 
      q.subject === subject && 
      q.difficulty === difficulty
    );
    allQuestions.push(...generatedQuestions);
    
    // Remove duplicates based on question ID
    const uniqueQuestions = this.removeDuplicateQuestions(allQuestions);
    
    return uniqueQuestions;
  }
  
  /**
   * Auto-generate questions when not enough exist
   */
  private static async autoGenerateQuestions(
    grade: string,
    subject: string,
    difficulty: DifficultyLevel,
    count: number
  ): Promise<Question[]> {
    console.log(`ðŸ¤– Auto-generating ${count} questions for ${subject}`);
    
    const generatedQuestions: Question[] = [];
    
    try {
      // Use specialized generators based on subject
      if (this.isReadingSubject(subject)) {
        // For reading, create more reading passages with questions
        const readingQuestions = await this.generateReadingQuestions(grade, difficulty, count);
        generatedQuestions.push(...readingQuestions);
        
      } else if (this.isThinkingSkillsSubject(subject)) {
        // Use robust thinking skills generator
        const thinkingQuestions = generateRobustThinkingSkillsQuestions(grade, difficulty, count);
        generatedQuestions.push(...thinkingQuestions);
        
      } else if (this.isMathReasoningSubject(subject)) {
        // Use mathematical reasoning generator
        const mathQuestions = generateEnhancedMathematicalReasoningQuestions(grade, difficulty, count);
        generatedQuestions.push(...mathQuestions);
        
      } else {
        // Use general enhanced question generator
        for (let i = 0; i < count; i++) {
          const question = generateEnhancedQuestion(grade, subject, difficulty);
          if (question) {
            generatedQuestions.push(question);
          }
        }
      }
      
      // Mark all generated questions with metadata
      generatedQuestions.forEach(q => {
        (q as any).isAutoGenerated = true;
        (q as any).generatedAt = new Date().toISOString();
        (q as any).generatedFor = `${grade}_${subject}_${difficulty}`;
      });
      
    } catch (error) {
      console.error('Error in auto-generation:', error);
      
      // Emergency fallback - create basic questions
      const emergencyQuestions = this.createEmergencyQuestions(grade, subject, difficulty, count);
      generatedQuestions.push(...emergencyQuestions);
    }
    
    console.log(`âœ… Auto-generated ${generatedQuestions.length} questions`);
    return generatedQuestions;
  }
  
  /**
   * Generate reading questions from passages
   */
  private static async generateReadingQuestions(
    grade: string,
    difficulty: DifficultyLevel,
    count: number
  ): Promise<Question[]> {
    // Get random passages from our comprehensive database
    const passages = ComprehensiveReadingDatabase.getRandomPassages(Math.ceil(count / 3), {
      grade,
      difficulty
    });
    
    const questions: Question[] = [];
    
    // Extract questions from passages
    passages.forEach(passage => {
      questions.push(...passage.questions);
    });
    
    // If we still need more, create additional questions from existing passages
    if (questions.length < count) {
      const additionalNeeded = count - questions.length;
      const morePassages = ComprehensiveReadingDatabase.getRandomPassages(
        Math.ceil(additionalNeeded / 2),
        { grade }
      );
      
      morePassages.forEach(passage => {
        questions.push(...passage.questions);
      });
    }
    
    return questions.slice(0, count);
  }
  
  /**
   * Create emergency questions as absolute fallback
   */
  private static createEmergencyQuestions(
    grade: string,
    subject: string,
    difficulty: DifficultyLevel,
    count: number
  ): Question[] {
    const questions: Question[] = [];
    
    for (let i = 0; i < count; i++) {
      const question: Question = {
        _id: `emergency_${Date.now()}_${i}`,
        content: `Emergency ${subject} question ${i + 1} for Grade ${grade}. This is a ${difficulty} level question.`,
        type: QuestionType.MULTIPLE_CHOICE,
        options: ['Correct answer', 'Option B', 'Option C', 'Option D'],
        correctAnswer: 'Correct answer',
        explanation: 'This is an emergency generated question to ensure the test can continue.',
        subject: subject,
        topic: 'Emergency Generation',
        difficulty: difficulty,
        grade: grade,
        tags: ['emergency', 'auto-generated'],
        createdBy: 'emergency-system',
        createdAt: new Date(),
        updatedAt: new Date()
      };
      
      questions.push(question);
    }
    
    return questions;
  }
  
  /**
   * Save generated questions to global pool for other users
   */
  private static async saveGeneratedQuestionsToGlobalPool(questions: Question[]): Promise<void> {
    try {
      const existingGenerated = getGeneratedQuestions();
      const allGenerated = [...existingGenerated, ...questions];
      
      // Remove duplicates
      const uniqueGenerated = this.removeDuplicateQuestions(allGenerated);
      
      saveGeneratedQuestions(uniqueGenerated);
      
      console.log(`ðŸ’¾ Saved ${questions.length} new questions to global pool`);
    } catch (error) {
      console.error('Error saving generated questions:', error);
    }
  }
  
  /**
   * Mark a question as answered by a user
   */
  static markQuestionAsAnswered(questionId: string, userId?: string): void {
    if (userId) {
      addAnsweredQuestionId(questionId);
      console.log(`âœ… Marked question ${questionId} as answered for user`);
    }
  }
  
  /**
   * Get statistics about question availability
   */
  static async getQuestionStats(grade: string, subject: string, difficulty: DifficultyLevel, userId?: string) {
    const allQuestions = await this.getAllAvailableQuestions(grade, subject, difficulty);
    const answeredIds = userId ? getAnsweredQuestionIds() : [];
    const availableForUser = allQuestions.filter(q => !answeredIds.includes(q._id));
    
    return {
      totalInGlobalPool: allQuestions.length,
      availableForUser: availableForUser.length,
      alreadyAnswered: answeredIds.length,
      sources: {
        original: allQuestions.filter(q => !(q as any).isGenerated && !(q as any).isAutoGenerated).length,
        reading: allQuestions.filter(q => q.subject === 'Reading').length,
        generated: allQuestions.filter(q => (q as any).isGenerated || (q as any).isAutoGenerated).length
      }
    };
  }
  
  // Helper methods
  private static isReadingSubject(subject: string): boolean {
    const readingSubjects = ['reading', 'reading comprehension', 'comprehension', 'literacy'];
    return readingSubjects.some(rs => subject.toLowerCase().includes(rs));
  }
  
  private static isThinkingSkillsSubject(subject: string): boolean {
    const thinkingSubjects = ['thinking skills', 'critical thinking', 'logic', 'thinking'];
    return thinkingSubjects.some(ts => subject.toLowerCase().includes(ts));
  }
  
  private static isMathReasoningSubject(subject: string): boolean {
    const mathSubjects = ['mathematical reasoning', 'math reasoning', 'reasoning'];
    return mathSubjects.some(ms => subject.toLowerCase().includes(ms));
  }
  
  private static shuffleArray<T>(array: T[]): T[] {
    const newArray = [...array];
    for (let i = newArray.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
    }
    return newArray;
  }
  
  private static removeDuplicateQuestions(questions: Question[]): Question[] {
    const seen = new Set<string>();
    return questions.filter(q => {
      if (seen.has(q._id)) {
        return false;
      }
      seen.add(q._id);
      return true;
    });
  }
  
  private static determineSource(questions: Question[]): 'database' | 'reading_passages' | 'generated' | 'mixed' {
    const hasGenerated = questions.some(q => (q as any).isGenerated || (q as any).isAutoGenerated);
    const hasReading = questions.some(q => q.subject === 'Reading');
    const hasOriginal = questions.some(q => !(q as any).isGenerated && !(q as any).isAutoGenerated);
    
    if (hasGenerated && (hasReading || hasOriginal)) return 'mixed';
    if (hasGenerated) return 'generated';
    if (hasReading) return 'reading_passages';
    return 'database';
  }
}

// Convenience functions for easy integration
export const getQuestionsForUser = (request: QuestionRequest) => 
  IntegratedQuestionManager.getQuestions(request);

export const markQuestionAnswered = (questionId: string, userId?: string) => 
  IntegratedQuestionManager.markQuestionAsAnswered(questionId, userId);

export const getQuestionStatistics = (grade: string, subject: string, difficulty: DifficultyLevel, userId?: string) =>
  IntegratedQuestionManager.getQuestionStats(grade, subject, difficulty, userId);

export default IntegratedQuestionManager;
